using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using System.Text;

namespace Paradigm.Enterprise.Interfaces
{
    //[Generator]
    public abstract class EntityInterfaceGeneratorBase : IIncrementalGenerator
    {
        #region Properties

        protected abstract string ProjectNamespace { get; }

        private readonly string[] AuditableProperties = ["CreationDate", "ModificationDate", "CreatedByUserId", "ModifiedByUserId"];

        private const string EntityBaseClassName = "EntityBase";

        #endregion

        #region Public Methods

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            //if (!Debugger.IsAttached) Debugger.Launch();

            try
            {
                var provider = context.SyntaxProvider
                    .CreateSyntaxProvider(predicate: (s, _) => s is ClassDeclarationSyntax,
                                          transform: (ctx, _) => (ClassDeclarationSyntax)ctx.Node)
                    .Where(c => c is not null && c.BaseList is not null && c.BaseList.Types.Any(IsEntityBase) && !IsView(c));

                var compilation = context.CompilationProvider.Combine(provider.Collect());
                context.RegisterSourceOutput(compilation, (spc, source) => Execute(spc, source.Left, source.Right));
            }
            catch (Exception ex)
            {
                Debug.WriteLine(ex.Message);
            }
        }

        #endregion

        #region Private Methods

        private void Execute(SourceProductionContext context, Compilation compilation, ImmutableArray<ClassDeclarationSyntax> typeList)
        {
            foreach (var type in typeList)
            {
                if (IsEntityBase(type))
                    continue;

                var classNamespace = GetNamespace(type);
                if (string.IsNullOrWhiteSpace(classNamespace)) continue;

                var className = type.Identifier.ValueText;
                var sourceCode = $@"// <auto-generated/>
#nullable enable

namespace {classNamespace?.Replace(".Domain.", ".Interfaces.")};

public partial interface I{className} : {ProjectNamespace}.Interfaces.Core.{nameof(IEntity)}
{{
{BuildProperties(compilation, type).TrimEnd()}

{BuildCollectionMethods(compilation, type).TrimEnd()}
}}";
                context.AddSource($"I{className}.g.cs", sourceCode);
            }
        }

        private bool IsView(ClassDeclarationSyntax cds) => cds.Identifier.ToString().EndsWith("View", StringComparison.OrdinalIgnoreCase);

        private bool IsEntityBase(ClassDeclarationSyntax cds) => cds.Identifier.ToString().StartsWith(EntityBaseClassName, StringComparison.OrdinalIgnoreCase);

        private bool IsEntityBase(BaseTypeSyntax bts) => bts.Type.ToString().StartsWith(EntityBaseClassName, StringComparison.OrdinalIgnoreCase);

        private bool IsGenericProperty(IPropertySymbol property) => property.Type is INamedTypeSymbol namedTypeSymbol && namedTypeSymbol.IsGenericType &&
            namedTypeSymbol.TypeKind is TypeKind.Interface or TypeKind.Class;

        private string? GetNamespace(ClassDeclarationSyntax classDeclaration)
        {
            var namespaceName = classDeclaration.Ancestors().OfType<NamespaceDeclarationSyntax>().FirstOrDefault()?.Name.ToString();

            if (string.IsNullOrWhiteSpace(namespaceName))
                namespaceName = classDeclaration.Ancestors().OfType<FileScopedNamespaceDeclarationSyntax>().FirstOrDefault()?.Name.ToString();

            return namespaceName;
        }

        private List<IPropertySymbol>? GetProperties(Compilation compilation, SyntaxNode syntaxNode)
        {
            var typeNodeSymbol = compilation
                .GetSemanticModel(syntaxNode.SyntaxTree)
                .GetDeclaredSymbol(syntaxNode) as INamedTypeSymbol;

            return typeNodeSymbol?.GetMembers()
                .Where(x => x.Kind.Equals(SymbolKind.Property) && x.DeclaredAccessibility.Equals(Accessibility.Public))
                .Select(x => x as IPropertySymbol)
                .Where(x => x is not null)
                .Cast<IPropertySymbol>()
                .ToList();
        }

        private string BuildProperties(Compilation compilation, ClassDeclarationSyntax classDeclaration)
        {
            try
            {
                var stringBuilder = new StringBuilder();
                var classProperties = GetProperties(compilation, classDeclaration).Where(x => !IsGenericProperty(x)).ToList();
                WriteProperties(stringBuilder, classProperties);
                return stringBuilder.ToString();
            }
            catch (Exception ex)
            {
                Debug.WriteLine(ex.ToString());
                return string.Empty;
            }
        }

        private void WriteProperties(StringBuilder stringBuilder, List<IPropertySymbol>? properties)
        {
            if (properties is null) return;

            var isAuditableEntity = AuditableProperties.All(x => properties.Any(y => x.Equals(y.Name, StringComparison.OrdinalIgnoreCase)));

            foreach (var prop in properties)
            {
                if (isAuditableEntity && AuditableProperties.Contains(prop.Name, StringComparer.OrdinalIgnoreCase))
                    continue;

                stringBuilder.AppendLine($"\t{prop.Type} {prop.Name} {{ get; }}");
            }
        }

        private string BuildCollectionMethods(Compilation compilation, ClassDeclarationSyntax classDeclaration)
        {
            try
            {
                var stringBuilder = new StringBuilder();
                var genericProperties = GetProperties(compilation, classDeclaration)
                    .Where(x => IsGenericProperty(x) && x.Type is INamedTypeSymbol namedTypeSymbol && namedTypeSymbol.TypeKind == TypeKind.Interface)
                    .ToList();

                foreach (var prop in genericProperties)
                {
                    var propType = prop.Type.ToString().Replace("IList", "IReadOnlyCollection");
                    var entityType = propType.Substring(propType.LastIndexOf('<'));
                    propType = propType.Replace(entityType, $"<I{entityType.Substring(entityType.LastIndexOf('.') + 1)}");
                    stringBuilder.AppendLine($"\t{propType} Get{prop.Name}();");
                }

                return stringBuilder.ToString();
            }
            catch (Exception ex)
            {
                Debug.WriteLine(ex.ToString());
                return string.Empty;
            }
        }

        #endregion
    }
}